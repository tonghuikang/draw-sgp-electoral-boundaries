<!DOCTYPE html>
<html>
<head>
  <title>Singapore Electoral Boundaries 2025</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    /* --- CSS Styles (mostly unchanged) --- */
    #map {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    body, html {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .status {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      max-width: 80%;
    }
    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    .legend-item {
      margin-bottom: 5px;
    }
    .legend-color {
      display: inline-block;
      width: 20px;
      height: 10px;
      margin-right: 5px;
      vertical-align: middle;
      border: 1px solid #555; /* Add border for visibility since fill is gone */
    }
    #overall-score {
      margin-top: 10px;
      padding-top: 5px;
      border-top: 1px solid #ddd;
    }
    #overall-score-value {
      font-weight: bold;
      color: #0066FF;
    }
    /* --- Tooltip/Popup Styles --- */
    .leaflet-tooltip { /* Style for hover tooltips (now only for Constituency Boundaries) */
      font-weight: bold;
      background-color: rgba(255, 255, 255, 0.9);
      border: 2px solid #FFA500;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.4);
      z-index: 1500 !important; /* Force high z-index */
    }
    .leaflet-popup-content-wrapper { /* Style popup */
        border-radius: 5px;
    }
    .leaflet-popup-content {
        margin: 10px;
        font-size: 12px;
        font-weight: bold;
        line-height: 1.4;
    }
    /* --- End Tooltip/Popup Styles --- */

    .polling-district-label div {
      text-align: center;
      white-space: nowrap;
      pointer-events: none;
      font-size: 8px;
      color: black;
      background: rgba(255, 255, 255, 0.8);
      padding: 1px 3px;
      border-radius: 2px;
      box-shadow: 0 0 1px #000;
    }
    .district-label {
      display: none;
    }
    .show-labels .district-label {
      display: block;
    }
    .adjacency-line {
        pointer-events: none;
    }
    /* --- Leaflet Popup Overrides (Crucial) --- */
    .leaflet-popup-content-wrapper {
        /* Optional: Add specific width if auto doesn't work */
        /* width: 250px !important; */
        border-radius: 5px !important; /* Keep your border radius if desired */
    }
    .leaflet-popup-content {
        margin: 0 !important; /* Remove default Leaflet margin */
        width: auto !important; /* Allow content to determine width */
        min-width: 210px; /* Set a minimum width to prevent squishing */
    }
    /* --- End Leaflet Popup Overrides --- */

    /* --- Popup Table Styles (Attempt 4 - Combined with Overrides) --- */
    .stats-popup-container {
        font-family: Arial, sans-serif;
        padding: 10px; /* Add padding INSIDE our container now */
        line-height: 1.5;
    }
    .stats-popup-header {
        text-align: center;
        margin-bottom: 10px;
        border-bottom: 1px solid #0066FF;
        padding-bottom: 6px;
        white-space: nowrap; /* Prevent line breaks in labels */
    }
    .stats-popup-title {
        color: #0066FF;
        font-size: 14px;
        font-weight: bold;
    }
    .stats-table {
        width: 100%; /* Table takes full width of its container */
        border-collapse: collapse;
        font-size: 12px;
        table-layout: auto; /* Let browser size columns based on content */
    }
    .stats-table tr {
        border-bottom: 1px solid #eee;
    }
    .stats-table tr:last-child {
        border-bottom: none;
    }
    .stats-table td {
        padding: 5px 4px;
        vertical-align: middle; /* Middle align vertically */
        /* display: table-cell !important; */ /* Still optional, try without first */
    }
    .stats-label {
        font-weight: bold;
        padding-right: 10px; /* Space between label and value */
        text-align: left;
        white-space: nowrap; /* Prevent line breaks in labels */
    }
    .stats-value {
        text-align: right;
        white-space: nowrap; /* Prevent line breaks in values */
    }
    .stats-table tr:nth-child(even) {
        background-color: #f9f9f9;
    }
    /* --- End Popup Table Styles --- */
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="controls">
    <div>
      <input type="checkbox" id="constituency-toggle" checked>
      <label for="constituency-toggle">Show Official 2025 Constituencies</label>
    </div>
    <div>
      <input type="checkbox" id="polling-toggle">
      <label for="polling-toggle">Show Polling Districts</label>
    </div>
  </div>
  <div id="status" class="status">Initializing map...</div>
  <!-- SIMPLIFIED LEGEND -->
  <div class="legend">
    <div class="legend-item">
      <span class="legend-color" style="background-color: transparent; border-color: #0066FF;"></span>
      <span>Constituency Boundaries</span>
    </div>
    <div class="legend-item">
      <span class="legend-color" style="background-color: transparent; border-color: #FF0000;"></span>
      <span>Polling Districts</span>
    </div>
    <div class="legend-item" id="overall-score">
      <strong>Overall Score: </strong><span id="overall-score-value"></span>
    </div>
  </div>
  <!-- END SIMPLIFIED LEGEND -->

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script>
    // --- Global Scope Variables ---
    const map = L.map('map').setView([1.3521, 103.8198], 12);
    
    // Create custom panes with different z-index values
    // This ensures smaller constituencies are rendered on top of larger ones
    map.createPane('defaultPane');
    map.createPane('smcPane'); // Single Member Constituencies pane
    map.createPane('labelPane'); // Special pane for labels and tooltips
    map.getPane('smcPane').style.zIndex = 650; // Higher than the default overlay pane (600)
    map.getPane('defaultPane').style.zIndex = 600; // Same as default overlay pane
    map.getPane('labelPane').style.zIndex = 3000; // Very high z-index to ensure labels are on top of everything
    
    // Use CartoDB Voyager for a cleaner base map that still shows transit lines
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }).addTo(map);
    
    // Coordinate display popup
    const coordPopup = L.popup({
      closeButton: true,
      autoClose: true,
      className: 'coord-popup',
      pane: 'labelPane' // Use the special pane for popups
    });

    // Create layers without adding them to the map yet
    let constituencyLayer = L.featureGroup();
    let pollingLayer = L.featureGroup();
    let adjacencyLinesLayer = L.layerGroup().addTo(map);
    
    // Add layers based on checkbox state
    if (document.getElementById('constituency-toggle').checked) {
      constituencyLayer.addTo(map);
    }
    if (document.getElementById('polling-toggle').checked) {
      pollingLayer.addTo(map);
    }

    let activeHighlight = null;
    let pollingDistrictLayers = {};
    let pollingDistrictProperties = {};
    let selectedDistrictForLines = null;
    let showElectorCount = true; // Always show elector count

    // --- Highlighting Logic ---
    function resetHighlightStyle(layer, defaultColor) {
       if (layer && typeof layer.setStyle === 'function') {
          // Check if this is a constituency boundary (blue) or polling district (red)
          const isConstituencyBoundary = defaultColor === '#0066FF';
          // Use weight 4 for constituency boundaries, 2 for polling districts
          const weight = isConstituencyBoundary ? 4 : 2;
          
          // Determine which pane to use based on whether this is an SMC
          let pane = 'defaultPane';
          if (isConstituencyBoundary && layer.feature && layer.feature.properties && layer.feature.properties.member_size === 1) {
              pane = 'smcPane';
          }
          
          // Calculate z-index for constituency boundaries based on polling district count
          let zIndex = 0;
          if (isConstituencyBoundary && layer.feature && layer.feature.properties && layer.feature.properties.polling_districts) {
              const maxPdCount = 100; // Assuming no constituency has more than 100 polling districts
              const pdCount = layer.feature.properties.polling_districts.length;
              zIndex = maxPdCount - pdCount; // Smaller constituencies get higher z-index
              
              // For single-member constituencies (SMCs), give them an even higher z-index
              if (layer.feature.properties.member_size === 1) {
                  zIndex += 200; // Add a large offset to ensure SMCs are always on top
              }
          }
          
          // Reset the style of the entire layer
          layer.setStyle({ 
              weight: weight, 
              color: defaultColor, 
              fillOpacity: 0, 
              opacity: 0.7,
              zIndex: zIndex,
              pane: pane
          });
       }
    }
    function highlightFeature(layer, defaultColor) {
        // First, clear any existing highlight
        if (activeHighlight && activeHighlight.layer !== layer) {
            resetHighlightStyle(activeHighlight.layer, activeHighlight.defaultColor);
        }
        
        // Check if this is a constituency boundary (blue) or polling district (red)
        const isConstituencyBoundary = defaultColor === '#0066FF';
        // Use weight 6 for constituency boundaries, 4 for polling districts when highlighted
        const highlightWeight = isConstituencyBoundary ? 6 : 4;
        
        // Apply highlight style to the entire layer
        if (layer && typeof layer.setStyle === 'function') {
            // For MultiPolygon or complex shapes, ensure the entire layer is highlighted
            layer.setStyle({ 
                weight: highlightWeight, 
                color: '#FFA500', // Orange highlight color
                fillOpacity: 0.2, 
                opacity: 0.9,
                // Ensure the entire layer is highlighted by setting a very high z-index
                zIndex: 2000 // Increased from 1000 to ensure it's above all other elements
            });
            
            // Bring the layer to the front to ensure it's visible
            if (layer.bringToFront && typeof layer.bringToFront === 'function') {
                if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                    layer.bringToFront();
                }
            }
        }
        
        // Store the active highlight for later reference
        activeHighlight = { layer: layer, defaultColor: defaultColor };
    }
    // --- End Highlighting Logic ---

    // Function to detect if a click is near a vertex
    function findNearestVertex(latlng, layer, tolerance = 10) {
        // Convert map click to pixel coordinates
        const clickPoint = map.latLngToContainerPoint(latlng);
        let closestDistance = Infinity;
        let closestVertex = null;
        
        // Helper function to process coordinates
        function processCoordinates(coords) {
            for (let i = 0; i < coords.length; i++) {
                // For Polygon, coords[0] is outer ring, the rest are holes
                if (Array.isArray(coords[i][0])) {
                    processCoordinates(coords[i]);
                } else {
                    // This is a vertex
                    const vertexLatLng = L.latLng(coords[i][1], coords[i][0]);
                    const vertexPoint = map.latLngToContainerPoint(vertexLatLng);
                    const distance = clickPoint.distanceTo(vertexPoint);
                    
                    if (distance < closestDistance && distance <= tolerance) {
                        closestDistance = distance;
                        closestVertex = vertexLatLng;
                    }
                }
            }
        }
        
        // Process all coordinates in the layer
        if (layer.feature && layer.feature.geometry) {
            const coords = layer.feature.geometry.coordinates;
            processCoordinates(coords);
        }
        
        return closestVertex;
    }
    
    // --- Parse GeoJSON ---
    function parseGeoJSON(geojsonData, featureGroup, color, isPollingDistrict = false) {
        if (!geojsonData || !geojsonData.features) {
            console.warn("Invalid or empty GeoJSON data provided for parsing.");
            return;
        }

        // Store references to individual layers for constituency boundaries
        const individualLayers = [];

        const layer = L.geoJSON(geojsonData, {
            style: feature => {
                // Calculate z-index for constituency boundaries based on polling district count
                let zIndex = 0;
                let isSMC = false;
                
                if (!isPollingDistrict && feature.properties && feature.properties.polling_districts) {
                    // Smaller constituencies (fewer polling districts) get higher z-index
                    // This ensures they are rendered on top of larger constituencies
                    const maxPdCount = 100; // Assuming no constituency has more than 100 polling districts
                    const pdCount = feature.properties.polling_districts.length;
                    zIndex = maxPdCount - pdCount; // Smaller constituencies get higher z-index
                    
                    // Check if this is a Single Member Constituency (SMC)
                    isSMC = feature.properties.member_size === 1;
                    if (isSMC) {
                        zIndex += 200; // Add a large offset to ensure SMCs are always on top
                    }
                }
                
                // Determine which pane to use
                const pane = !isPollingDistrict && isSMC ? 'smcPane' : 'defaultPane';
                
                return { 
                    color: color, 
                    weight: isPollingDistrict ? 2 : 4, // Only constituency boundaries are bolder (4), polling districts stay at 2
                    opacity: 0.7, 
                    fillOpacity: 0,
                    zIndex: zIndex, // Add z-index based on polling district count
                    pane: pane, // Use the appropriate pane
                    interactive: true // Ensure the layer is clickable
                };
            },
            onEachFeature: function(feature, layer) {
                let labelText = ''; // Label for high zoom
                let popupContent = ''; // Content for click popup
                let tooltipContent = ''; // Content for hover tooltip (non-polling)
                const props = feature.properties || {};
                const pdName = props.name || props.Name || props.polling_district;

                if (isPollingDistrict) {
                    // --- Polling District Specific Logic ---
                    const electorSize = props.elector_size;
                    if (pdName) {
                        labelText = pdName; // For high-zoom label
                        // Prepare content for the popup (shown on click)
                        popupContent = `<div class="stats-popup-container">
                            <div class="stats-popup-header">
                                <span class="stats-popup-title">${pdName}</span>
                            </div>
                            <table class="stats-table">`;
                            
                        // Add elector count
                        if (electorSize !== undefined && electorSize !== null) {
                            popupContent += `<tr>
                                <td class="stats-label">Elector Count</td>
                                <td class="stats-value">${Number(electorSize).toLocaleString()}</td>
                            </tr>`;
                        } else {
                            popupContent += `<tr>
                                <td class="stats-label">Elector Count</td>
                                <td class="stats-value">No data</td>
                            </tr>`;
                        }
                        
                        // Add nearest MRTs
                        if (props.nearest_mrts && props.nearest_mrts.length > 0) {
                            popupContent += `<tr>
                                <td class="stats-label">Nearest MRTs</td>
                                <td class="stats-value">${props.nearest_mrts.join('<br>')}</td>
                            </tr>`;
                        }
                        
                        popupContent += `</table></div>`;

                        // Store references
                        pollingDistrictLayers[pdName] = layer;
                        pollingDistrictProperties[pdName] = props;

                        // *** Bind Popup only if showElectorCount is true ***
                        if (showElectorCount) {
                            layer.bindPopup(popupContent);
                        }

                    } else {
                        // Fallback for unnamed polling districts
                        popupContent = `<div class="stats-popup-container">
                            <div class="stats-popup-header">
                                <span class="stats-popup-title">Polling District (No Name)</span>
                            </div>
                            <table class="stats-table">`;
                            
                        // Add any available information
                        if (props.elector_size !== undefined && props.elector_size !== null) {
                            popupContent += `<tr>
                                <td class="stats-label">Elector Count</td>
                                <td class="stats-value">${Number(props.elector_size).toLocaleString()}</td>
                            </tr>`;
                        }
                        
                        // Add nearest major MRT if available
                        if (props.nearest_major_mrt && props.nearest_major_mrt.name) {
                            popupContent += `<tr>
                                <td class="stats-label">Nearest Major MRT</td>
                                <td class="stats-value">${props.nearest_major_mrt.name}</td>
                            </tr>`;
                        }
                        
                        // Add nearest minor MRT if available
                        if (props.nearest_minor_mrt && props.nearest_minor_mrt.name) {
                            popupContent += `<tr>
                                <td class="stats-label">Nearest Minor MRT</td>
                                <td class="stats-value">${props.nearest_minor_mrt.name}</td>
                            </tr>`;
                        }
                        
                        popupContent += `</table></div>`;
                        layer.bindPopup(popupContent);
                    }

                    // Add high-zoom label marker at center of mass
                    if (labelText && layer.feature && layer.feature.geometry) {
                        // Calculate center of mass using turf.js
                        const centroid = turf.centerOfMass(layer.feature);
                        // Convert turf point [lng, lat] to Leaflet [lat, lng]
                        const center = L.latLng(centroid.geometry.coordinates[1], centroid.geometry.coordinates[0]);
                        
                        L.marker(center, {
                            icon: L.divIcon({
                                className: 'polling-district-label',
                                html: `<div class="district-label">${labelText}</div>`,
                                iconSize: [30, 12], iconAnchor: [15, 6]
                            }),
                            interactive: false, keyboard: false
                        }).addTo(map);
                    }
                     // --- End Polling District Specific Logic ---

                } else {
                    // --- Constituency Boundary Logic (Keep hover tooltip) ---
                    tooltipContent = props.name || props.Name || props.NAME || props.CONSTITUENCY || props.constituency || 'Constituency Boundary (No Name)';
                    if (tooltipContent) {
                        layer.bindTooltip(tooltipContent, { 
                            permanent: false, 
                            direction: 'center', 
                            className: 'constituency-tooltip', 
                            sticky: true, 
                            opacity: 0.9, 
                            interactive: false,
                            zIndexOffset: 3000, // Ensure tooltips appear above all other elements
                            pane: 'labelPane' // Use the special pane for tooltips
                        });
                        
                        // Add popup for constituency boundaries with statistics
                        const constituencyName = tooltipContent;
                        // Create popup content with preloaded statistics
                        const popupId = `constituency-popup-${constituencyName.replace(/\s+/g, '-')}`;
                        const popupContent = `<div id="${popupId}" class="constituency-popup"></div>`;
                        layer.bindPopup(popupContent);
                        
                        // Pre-populate popup content when binding
                        layer.on('popupopen', function() {
                            const popupElement = document.getElementById(popupId);
                            if (popupElement) {
                                getConstituencyStatistics(constituencyName, popupElement);
                            }
                        });
                    }
                    // --- End Constituency Boundary Logic ---
                }


                // --- Event Handlers ---
                layer.on({
                    mouseover: function(e) {
                        // Highlight still happens on hover for both types
                        highlightFeature(layer, color);
                        L.DomEvent.stopPropagation(e);
                        
                        // Draw adjacency lines ONLY for polling districts on mouseover
                        if (isPollingDistrict && pdName) {
                            adjacencyLinesLayer.clearLayers();
                            selectedDistrictForLines = pdName;
                            const propsA = pollingDistrictProperties[pdName];
                            const layerA = pollingDistrictLayers[pdName];

                            if (!layerA || !layerA.getBounds().isValid() || !propsA) {
                                console.error(`Missing data or invalid bounds for hovered district: ${pdName}`);
                                return;
                            }

                            // Calculate center of mass of district A using turf.js
                            const centroidA = turf.centerOfMass(layerA.feature);
                            // Convert turf point [lng, lat] to Leaflet [lat, lng]
                            const centerA = L.latLng(centroidA.geometry.coordinates[1], centroidA.geometry.coordinates[0]);
                            const directAdjacentNames = propsA.adjacent_districts || [];

                            // Draw A->B lines
                            directAdjacentNames.forEach(nameB => {
                                const layerB = pollingDistrictLayers[nameB];
                                const propsB = pollingDistrictProperties[nameB];

                                if (layerB && layerB.feature && propsB) {
                                    // Calculate center of mass of district B
                                    const centroidB = turf.centerOfMass(layerB.feature);
                                    // Convert turf point [lng, lat] to Leaflet [lat, lng]
                                    const centerB = L.latLng(centroidB.geometry.coordinates[1], centroidB.geometry.coordinates[0]);
                                    
                                    L.polyline([centerA, centerB], {
                                        color: 'purple', weight: 2, opacity: 0.8, dashArray: '5, 5', className: 'adjacency-line'
                                    }).addTo(adjacencyLinesLayer);

                                    // Draw B->C lines
                                    const secondaryAdjacentNames = propsB.adjacent_districts || [];
                                    secondaryAdjacentNames.forEach(nameC => {
                                        if (nameC === pdName) { return; } // Skip B->A line

                                        const layerC = pollingDistrictLayers[nameC];
                                        if (layerC && layerC.feature) {
                                            // Calculate center of mass of district C
                                            const centroidC = turf.centerOfMass(layerC.feature);
                                            // Convert turf point [lng, lat] to Leaflet [lat, lng]
                                            const centerC = L.latLng(centroidC.geometry.coordinates[1], centroidC.geometry.coordinates[0]);
                                            
                                            L.polyline([centerB, centerC], {
                                                color: 'green', weight: 2, opacity: 0.7, dashArray: '2, 4', className: 'adjacency-line'
                                            }).addTo(adjacencyLinesLayer);
                                        } else {
                                            console.warn(`      Could not find layer/feature for indirect adjacent (C): ${nameC}`);
                                        }
                                    });
                                } else {
                                    console.warn(`  Could not find layer/feature/props for direct adjacent (B): ${nameB}`);
                                }
                            });
                        }
                    },
                    mouseout: function(e) {
                        // Clear adjacency lines when mouse leaves the district
                        if (isPollingDistrict) {
                            adjacencyLinesLayer.clearLayers();
                            selectedDistrictForLines = null;
                        }
                    },
                    click: function(e) {
                        // Highlight happens on click
                        highlightFeature(layer, color);
                        // Stop propagation so the map click doesn't immediately clear lines/highlight
                        // and allows the popup to open.
                        L.DomEvent.stopPropagation(e);
                        
                        // For constituency boundaries, show statistics
                        if (!isPollingDistrict) {
                            const constituencyName = props.name || props.Name || props.NAME || props.CONSTITUENCY || props.constituency;
                            if (constituencyName) {
                                // When popup opens, show the statistics
                                layer.on('popupopen', function() {
                                    const popupElement = document.getElementById(`constituency-popup-${constituencyName.replace(/\s+/g, '-')}`);
                                    if (popupElement) {
                                        getConstituencyStatistics(constituencyName, popupElement);
                                    }
                                });
                            }
                        }
                        
                        // Check if click is near a vertex
                        const nearestVertex = findNearestVertex(e.latlng, layer);
                        if (nearestVertex) {
                            // Format coordinates as "longitude,latitude,0" without trailing zeros
                            const lng = parseFloat(nearestVertex.lng.toFixed(6)).toString();
                            const lat = parseFloat(nearestVertex.lat.toFixed(6)).toString();
                            const coordText = `${lng},${lat},0`;
                            
                            // Only show coordinates popup if "Show Polling Districts" is checked
                            if (document.getElementById('polling-toggle').checked) {
                                // Show popup with coordinates
                                coordPopup
                                    .setLatLng(nearestVertex)
                                    .setContent(`<div><strong>Coordinates:</strong><br>${coordText}</div>`)
                                    .openOn(map);
                            }
                        }

                        // Note: The popup bound with layer.bindPopup() will open automatically
                        // on click due to Leaflet's default behavior. No extra code needed here for that.
                    } // end click function
                }); // end layer.on
            } // end onEachFeature
        }).addTo(featureGroup);

        // If these are constituency boundaries, ensure smaller constituencies are on top
        if (!isPollingDistrict && geojsonData.features) {
            // The features are already sorted by polling district count (ascending)
            // Bring each layer to front in reverse order (smallest to largest)
            layer.eachLayer(function(l) {
                if (l.feature && l.feature.properties && l.feature.properties.polling_districts) {
                    // Store reference to layer and its polling district count
                    const memberSize = l.feature.properties.member_size || 0;
                    individualLayers.push({
                        layer: l,
                        count: l.feature.properties.polling_districts.length,
                        isSMC: memberSize === 1 // Flag for Single Member Constituencies
                    });
                }
            });

            // Sort layers by polling district count (ascending) and prioritize SMCs
            individualLayers.sort((a, b) => {
                // First prioritize SMCs over GRCs
                if (a.isSMC && !b.isSMC) return 1; // SMCs should be last in the array so they're brought to front last
                if (!a.isSMC && b.isSMC) return -1;
                // Then sort by polling district count (ascending)
                return a.count - b.count;
            });

            // Bring smaller constituencies to front
            individualLayers.forEach(item => {
                if (item.layer.bringToFront) {
                    item.layer.bringToFront();
                }
            });
            
        }
    } // End parseGeoJSON

    // --- Construct Constituency Boundaries from Assignments ---
    async function constructConstituencyBoundaries(pollingGeoJSON, assignments) {
        
        // Create a mapping of polling district codes to their GeoJSON features
        const pollingDistrictMap = {};
        pollingGeoJSON.features.forEach(feature => {
            const pdName = feature.properties.name || feature.properties.Name || feature.properties.polling_district;
            if (pdName) {
                pollingDistrictMap[pdName] = feature;
            }
        });
        
        // Create constituency boundaries based on assignments
        let constituencyFeatures = [];
        
        for (const constituency of assignments.assignment) {
            const constituencyName = constituency.constituency_name;
            const memberSize = constituency.member_size;
            const electorSize = constituency.elector_size;
            const pollingDistricts = constituency.polling_districts;
            
            // Skip if no polling districts
            if (!pollingDistricts || pollingDistricts.length === 0) {
                console.warn(`No polling districts for ${constituencyName}`);
                continue;
            }
            
            
            try {
                // Collect all valid polygon features for this constituency
                const validPolygons = [];
                
                for (const pdName of pollingDistricts) {
                    const pdFeature = pollingDistrictMap[pdName];
                    if (!pdFeature || !pdFeature.geometry) {
                        console.warn(`Could not find geometry for polling district: ${pdName}`);
                        continue;
                    }
                    
                    // Convert any MultiPolygon to individual Polygons
                    if (pdFeature.geometry.type === "MultiPolygon") {
                        pdFeature.geometry.coordinates.forEach(polygonCoords => {
                            validPolygons.push({
                                type: "Feature",
                                properties: pdFeature.properties,
                                geometry: {
                                    type: "Polygon",
                                    coordinates: polygonCoords
                                }
                            });
                        });
                    } else if (pdFeature.geometry.type === "Polygon") {
                        validPolygons.push(pdFeature);
                    }
                }
                
                if (validPolygons.length === 0) {
                    console.warn(`No valid polygons found for ${constituencyName}`);
                    continue;
                }
                
                // Start with the first polygon
                let mergedPolygon = validPolygons[0];
                
                // Merge all polygons into one
                for (let i = 1; i < validPolygons.length; i++) {
                    try {
                        mergedPolygon = turf.union(mergedPolygon, validPolygons[i]);
                    } catch (unionError) {
                        console.warn(`Error merging polygon ${i} for ${constituencyName}: ${unionError.message}`);
                        // Continue with the current merged polygon
                    }
                }
                
                // Extract the outline coordinates
                let outlineCoordinates;
                
                if (mergedPolygon.geometry.type === "Polygon") {
                    // Use only the outer ring (first ring) of the polygon
                    outlineCoordinates = mergedPolygon.geometry.coordinates[0];
                } else if (mergedPolygon.geometry.type === "MultiPolygon") {
                    // For MultiPolygon, we'll use the largest polygon's outer ring
                    let largestArea = 0;
                    let largestPolygon = null;
                    
                    for (const polygon of mergedPolygon.geometry.coordinates) {
                        const polygonFeature = {
                            type: "Feature",
                            properties: {},
                            geometry: {
                                type: "Polygon",
                                coordinates: polygon
                            }
                        };
                        
                        const area = turf.area(polygonFeature);
                        if (area > largestArea) {
                            largestArea = area;
                            largestPolygon = polygon;
                        }
                    }
                    
                    outlineCoordinates = largestPolygon ? largestPolygon[0] : null;
                }
                
                if (!outlineCoordinates) {
                    throw new Error("Could not extract outline coordinates");
                }
                
                // Create a feature with the outline as a Polygon (not LineString)
                // This allows tooltips to work when hovering over the area, not just the edge
                const constituencyFeature = {
                    type: "Feature",
                    properties: {
                        name: constituencyName,
                        member_size: memberSize,
                        elector_size: electorSize,
                        polling_districts: pollingDistricts
                    },
                    geometry: {
                        type: "Polygon",
                        coordinates: [outlineCoordinates] // Wrap in array as Polygon requires array of rings
                    }
                };
                
                constituencyFeatures.push(constituencyFeature);
                
            } catch (error) {
                console.error(`Error processing constituency ${constituencyName}:`, error);
                
                // Fallback: create a convex hull as a simple outline
                try {
                    
                    // Collect all points from all polling districts
                    const allPoints = [];
                    
                    for (const pdName of pollingDistricts) {
                        const pdFeature = pollingDistrictMap[pdName];
                        if (!pdFeature || !pdFeature.geometry) continue;
                        
                        if (pdFeature.geometry.type === "Polygon") {
                            pdFeature.geometry.coordinates[0].forEach(point => {
                                allPoints.push(point);
                            });
                        } else if (pdFeature.geometry.type === "MultiPolygon") {
                            pdFeature.geometry.coordinates.forEach(polygon => {
                                polygon[0].forEach(point => {
                                    allPoints.push(point);
                                });
                            });
                        }
                    }
                    
                    if (allPoints.length === 0) {
                        console.warn(`No points found for ${constituencyName}`);
                        continue;
                    }
                    
                    // Create a feature collection of points
                    const pointFeatures = allPoints.map(point => ({
                        type: "Feature",
                        properties: {},
                        geometry: {
                            type: "Point",
                            coordinates: point
                        }
                    }));
                    
                    const featureCollection = {
                        type: "FeatureCollection",
                        features: pointFeatures
                    };
                    
                    // Create a convex hull
                    const hull = turf.convex(featureCollection);
                    
                    if (hull) {
                        // Extract just the outline as a LineString
                        const outline = hull.geometry.coordinates[0];
                        
                        // Create a feature with the outline
                        const constituencyFeature = {
                            type: "Feature",
                            properties: {
                                name: constituencyName,
                                member_size: memberSize,
                                elector_size: electorSize,
                                polling_districts: pollingDistricts
                            },
                            geometry: {
                                type: "LineString",
                                coordinates: outline
                            }
                        };
                        
                        constituencyFeatures.push(constituencyFeature);
                    } else {
                        throw new Error("Failed to create convex hull");
                    }
                } catch (convexError) {
                    console.error(`Convex hull failed for ${constituencyName}:`, convexError);
                }
            }
        }
        
        // Sort constituency features by member size and polling district count
        // This ensures SMCs and smaller constituencies are rendered on top of larger ones
        constituencyFeatures.sort((a, b) => {
            const aIsSMC = a.properties.member_size === 1;
            const bIsSMC = b.properties.member_size === 1;
            
            // First prioritize SMCs over GRCs
            if (aIsSMC && !bIsSMC) return 1; // SMCs should be last in the array so they're processed last
            if (!aIsSMC && bIsSMC) return -1;
            
            // Then sort by polling district count (ascending)
            const aPollingDistrictsCount = a.properties.polling_districts ? a.properties.polling_districts.length : 0;
            const bPollingDistrictsCount = b.properties.polling_districts ? b.properties.polling_districts.length : 0;
            return aPollingDistrictsCount - bPollingDistrictsCount; // Ascending order (smaller on top)
        });
        
        
        return {
            type: "FeatureCollection",
            features: constituencyFeatures
        };
    }

    // Store preloaded statistics
    let constituencyStatistics = {};
    
    // Function to preload all statistics from annotations file
    async function preloadConstituencyStatistics() {
        try {
            const response = await fetch('annotations/official_ge_2025.json');
            if (!response.ok) {
                throw new Error(`HTTP status ${response.status}`);
            }
            
            const data = await response.json();
            // Store all statistics in a map for quick access
            data.annotations.forEach(constituency => {
                constituencyStatistics[constituency.constituency_name] = constituency;
            });
            
            // Display overall score in the legend
            if (data.overall_score !== undefined) {
                const scoreElement = document.getElementById('overall-score-value');
                if (scoreElement) {
                    scoreElement.textContent = (data.overall_score * 100).toFixed(2) + '%';
                }
            } else {
                // Hide the overall score element if no data is available
                const overallScoreElement = document.getElementById('overall-score');
                if (overallScoreElement) {
                    overallScoreElement.style.display = 'none';
                }
            }
            
            console.log("Constituency statistics preloaded successfully");
            return true;
        } catch (error) {
            console.error("Error preloading statistics:", error);
            // Hide the overall score element since we couldn't load the data
            const overallScoreElement = document.getElementById('overall-score');
            if (overallScoreElement) {
                overallScoreElement.style.display = 'none';
            }
            return false;
        }
    }
    
    // Function to get statistics for a constituency
    function getConstituencyStatistics(constituencyName, popupElement) {
        const constituencyData = constituencyStatistics[constituencyName];
        
        if (constituencyData) {
            // Create a proper table with better styling using CSS classes
            let content = `
                <div class="stats-popup-container">
                    <div class="stats-popup-header">
                        <span class="stats-popup-title">${constituencyName}${constituencyData.member_size === 1 ? ' SMC' : ' GRC'}</span>
                    </div>
                    <table class="stats-table">
                        <tr>
                            <td class="stats-label">Member Size</td>
                            <td class="stats-value">${constituencyData.member_size}</td>
                        </tr>
                        <tr>
                            <td class="stats-label">Elector Size</td>
                            <td class="stats-value">${Number(constituencyData.elector_size).toLocaleString()}</td>
                        </tr>
                        <tr>
                            <td class="stats-label">Elector per Member</td>
                            <td class="stats-value">${(constituencyData.elector_size / constituencyData.member_size).toFixed(2)}</td>
                        </tr>
                        <tr>
                            <td class="stats-label">Elector Balance</td>
                            <td class="stats-value">${(constituencyData.elector_balance * 100).toFixed(2)}%</td>
                        </tr>
                        <tr>
                            <td class="stats-label">Nonenclavity</td>
                            <td class="stats-value">${(constituencyData.nonenclavity * 100).toFixed(2)}%</td>
                        </tr>
                        <tr>
                            <td class="stats-label">Compactness</td>
                            <td class="stats-value">${(constituencyData.compactness * 100).toFixed(2)}%</td>
                        </tr>
                        <tr>
                            <td class="stats-label">Convexity</td>
                            <td class="stats-value">${(constituencyData.convexity * 100).toFixed(2)}%</td>
                        </tr>
                        <tr>
                            <td class="stats-label">Relevance</td>
                            <td class="stats-value">${(constituencyData.relevance * 100).toFixed(2)}%</td>
                        </tr>
                        <tr>
                            <td class="stats-label">Contiguous</td>
                            <td class="stats-value">${constituencyData.contiguous ? 'Yes' : 'No'}</td>
                        </tr>
                        <tr>
                            <td class="stats-label">Constituency Score</td>
                            <td class="stats-value">${(constituencyData.constituency_score * 100).toFixed(2)}%</td>
                        </tr>
                    </table>
                </div>
            `;
            
            popupElement.innerHTML = content;
        } else {
            popupElement.innerHTML = `<div style="text-align: center; padding: 10px;"><strong>${constituencyName}</strong><br>No statistics available</div>`;
        }
    }

    // --- Load All Layers ---
    async function loadAllLayers() {
        const localAssignmentsUrl = 'assignments/official_ge_2025.json';
        const localPollingUrl = 'processed_data/ge2025_polling_districts_with_information.geojson';
        const githubBaseUrl = 'https://raw.githubusercontent.com/tonghuikang/electoral-boundaries/master/';
        const githubAssignmentsUrl = githubBaseUrl + localAssignmentsUrl;
        const githubPollingUrl = githubBaseUrl + localPollingUrl;
        
        const statusElement = document.getElementById('status');
        statusElement.innerHTML = "Attempting to load map data...";
        statusElement.style.display = 'block';
        let bounds = L.latLngBounds();
        let assignmentsData = null;
        let pollingGeoJSON = null;
        let constituencyGeoJSON = null;
        let assignmentsSource = 'local';
        let pollingSource = 'local';
        pollingDistrictLayers = {};
        pollingDistrictProperties = {};

        try {
            // Fetch Assignments with fallback
            try {
                const response = await fetch(localAssignmentsUrl);
                if (!response.ok) throw new Error(`HTTP status ${response.status} for local assignments`);
                assignmentsData = await response.json();
                statusElement.innerHTML = "Loaded local assignments data...";
                assignmentsSource = 'local';
            } catch (localError) {
                console.error(`Failed to load local assignments: ${localError.message}`);
                statusElement.innerHTML = "Local assignments not available, trying GitHub...";
                
                try {
                    const githubResponse = await fetch(githubAssignmentsUrl);
                    if (!githubResponse.ok) throw new Error(`HTTP status ${githubResponse.status} for GitHub assignments`);
                    assignmentsData = await githubResponse.json();
                    statusElement.innerHTML = "Loaded assignments data from GitHub...";
                    assignmentsSource = 'github';
                } catch (githubError) {
                    console.error(`Failed to load assignments from GitHub: ${githubError.message}`);
                    statusElement.innerHTML = "Failed to load assignments data from any source.";
                }
            }

            // Fetch Polling with fallback
            try {
                const response = await fetch(localPollingUrl);
                if (!response.ok) throw new Error(`HTTP status ${response.status} for local polling`);
                pollingGeoJSON = await response.json();
                statusElement.innerHTML = "Loaded local polling data...";
                pollingSource = 'local';
            } catch (localError) {
                console.error(`Failed to load local polling districts: ${localError.message}`);
                statusElement.innerHTML = "Local polling data not available, trying GitHub...";
                
                try {
                    const githubResponse = await fetch(githubPollingUrl);
                    if (!githubResponse.ok) throw new Error(`HTTP status ${githubResponse.status} for GitHub polling`);
                    pollingGeoJSON = await githubResponse.json();
                    statusElement.innerHTML = "Loaded polling data from GitHub...";
                    pollingSource = 'github';
                } catch (githubError) {
                    console.error(`Failed to load polling districts from GitHub: ${githubError.message}`);
                    statusElement.innerHTML = "Failed to load polling data from any source.";
                }
            }

            // Construct Constituency Boundaries from Assignments and Polling Districts
            if (assignmentsData && pollingGeoJSON) {
                statusElement.textContent = "Constructing constituency boundaries...";
                constituencyGeoJSON = await constructConstituencyBoundaries(pollingGeoJSON, assignmentsData);
            } else {
                console.error("Missing data needed to construct constituency boundaries");
                statusElement.textContent += " Failed to construct constituency boundaries.";
            }

            // Parse
            statusElement.textContent = "Processing map data...";
            if (constituencyGeoJSON) {
                parseGeoJSON(constituencyGeoJSON, constituencyLayer, '#0066FF', false); // Blue outline, has tooltip
                if (constituencyLayer.getBounds().isValid()) bounds.extend(constituencyLayer.getBounds());
            } else { statusElement.textContent += " Failed to load constituency data."; }

            if (pollingGeoJSON) {
                parseGeoJSON(pollingGeoJSON, pollingLayer, '#FF0000', true); // Red outline, has popup
                if (pollingLayer.getBounds().isValid()) bounds.extend(pollingLayer.getBounds());
            } else { statusElement.textContent += " Failed to load polling data."; }

            // Fit Map
            if (bounds.isValid()) { map.fitBounds(bounds); }
            else { console.warn("Invalid bounds. Setting default view."); map.setView([1.3521, 103.8198], 12); }

            // Final Status
            let finalStatus = "Map loaded (";
            if (assignmentsData && pollingGeoJSON) {
                finalStatus += `Assignments: ${assignmentsSource}, Polling: ${pollingSource})`;
            } else {
                finalStatus += "Partial data only)";
            }
            statusElement.textContent = finalStatus; 
            setTimeout(() => {
                 const currentStatus = statusElement.textContent.toLowerCase();
                 if (!currentStatus.includes('error') && !currentStatus.includes('failed')) {
                     statusElement.style.display = 'none';
                 }
            }, 4000);

        } catch (error) {
            console.error("Fatal error during map loading:", error);
            statusElement.textContent = `Error loading map: ${error.message}`;
            statusElement.style.display = 'block';
        } finally { handleZoomEnd(); }
    }
    // --- End Load All Layers ---

    // --- Toggle Controls (unchanged) ---
    document.getElementById('constituency-toggle').addEventListener('change', function() {
        if (this.checked) { map.addLayer(constituencyLayer); }
        else {
            if (activeHighlight && constituencyLayer.hasLayer(activeHighlight.layer)) {
                resetHighlightStyle(activeHighlight.layer, activeHighlight.defaultColor);
                activeHighlight = null;
            }
            map.removeLayer(constituencyLayer);
        }
    });
    document.getElementById('polling-toggle').addEventListener('change', function() {
        if (this.checked) { map.addLayer(pollingLayer); }
        else {
            if (activeHighlight && pollingLayer.hasLayer(activeHighlight.layer)) {
                resetHighlightStyle(activeHighlight.layer, activeHighlight.defaultColor);
                activeHighlight = null;
            }
            adjacencyLinesLayer.clearLayers();
            selectedDistrictForLines = null;
            // Close any open popups when hiding the layer
            map.closePopup();
            map.removeLayer(pollingLayer);
        }
    });
    // Elector count toggle removed - popups are always shown
    // --- End Toggle Controls ---

    // --- Global Event Handlers ---
    map.on('click', function() {
        // Clear highlight on map click
        if (activeHighlight) {
            resetHighlightStyle(activeHighlight.layer, activeHighlight.defaultColor);
            activeHighlight = null;
        }
        // Popups are automatically closed by Leaflet on map click, usually.
    });

    const mapContainer = map.getContainer(); // Clear highlight on map mouseout (unchanged)
    if (mapContainer) {
        mapContainer.addEventListener('mouseout', (e) => {
            if (!mapContainer.contains(e.relatedTarget)) {
                 if (activeHighlight) {
                    resetHighlightStyle(activeHighlight.layer, activeHighlight.defaultColor);
                    activeHighlight = null;
                }
            }
        });
    } else { console.error("Could not get map container."); }
    // --- End Global Event Handlers ---

    // --- Zoom Handling (unchanged) ---
    function handleZoomEnd() {
        const zoom = map.getZoom();
        const mapElement = document.getElementById('map');
        if (zoom >= 14) { mapElement.classList.add('show-labels'); }
        else { mapElement.classList.remove('show-labels'); }
    }
    map.on('zoomend', handleZoomEnd);
    // --- End Zoom Handling ---

    // --- Initial Load ---
    document.addEventListener('DOMContentLoaded', async function() {
        document.getElementById('status').textContent = "Initializing...";
        
        // Preload constituency statistics
        await preloadConstituencyStatistics();
        
        // Load map layers
        loadAllLayers();
    });
    // --- End Initial Load ---

  </script>
</body>
</html>
