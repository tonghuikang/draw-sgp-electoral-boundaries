<!DOCTYPE html>
<html>
<head>
  <title>Singapore Electoral Boundaries 2025</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    body, html {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .status {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    .legend-item {
      margin-bottom: 5px;
    }
    .legend-color {
      display: inline-block;
      width: 20px;
      height: 10px;
      margin-right: 5px;
    }
    .leaflet-tooltip {
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <div class="controls">
    <div>
      <input type="checkbox" id="electoral-toggle" checked>
      <label for="electoral-toggle">Show Electoral Boundaries</label>
    </div>
    <div>
      <input type="checkbox" id="polling-toggle" checked>
      <label for="polling-toggle">Show Polling Districts</label>
    </div>
  </div>
  
  <div id="status" class="status">
    Loading map data...
  </div>
  
  <div class="legend">
    <div class="legend-item">
      <span class="legend-color" style="background-color: #0066FF;"></span>
      <span>Electoral Boundaries</span>
    </div>
    <div class="legend-item">
      <span class="legend-color" style="background-color: #FF0000;"></span>
      <span>Polling Districts</span>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Initialize the map
    const map = L.map('map').setView([1.3521, 103.8198], 12);
    
    // Add OpenStreetMap tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    
    // Create our layers
    let electoralLayer = L.featureGroup().addTo(map);
    let pollingLayer = L.featureGroup().addTo(map);
    
    // Function to fetch data from a URL
    async function fetchData(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
        }
        return await response.text();
      } catch (error) {
        console.error("Error fetching data:", error);
        document.getElementById('status').textContent = `Error loading data: ${error.message}`;
        return null;
      }
    }
    
    // Parse KML text
    function parseKML(kmlText, featureGroup, color) {
      // Create a temporary DOM to parse the KML
      const parser = new DOMParser();
      const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
      
      // Find all placemarks
      const placemarks = kmlDoc.getElementsByTagName('Placemark');
      document.getElementById('status').textContent = `Found ${placemarks.length} placemarks in KML`;
      
      for (let i = 0; i < placemarks.length; i++) {
        const placemark = placemarks[i];
        
        // Get name if available
        let name = '';
        const nameEl = placemark.getElementsByTagName('name')[0];
        if (nameEl) {
          name = nameEl.textContent;
        }
        
        // Find all polygons
        const polygons = placemark.getElementsByTagName('Polygon');
        for (let j = 0; j < polygons.length; j++) {
          const polygon = polygons[j];
          const coords = extractCoordinates(polygon);
          if (coords.length > 0) {
            addPolygonToMap(coords, name, featureGroup, color);
          }
        }
        
        // Find multigeometries
        const multiGeometries = placemark.getElementsByTagName('MultiGeometry');
        for (let j = 0; j < multiGeometries.length; j++) {
          const multiPolygons = multiGeometries[j].getElementsByTagName('Polygon');
          for (let k = 0; k < multiPolygons.length; k++) {
            const polygon = multiPolygons[k];
            const coords = extractCoordinates(polygon);
            if (coords.length > 0) {
              addPolygonToMap(coords, name, featureGroup, color);
            }
          }
        }
      }
      
      // Fit the map to the boundaries
      if (featureGroup.getBounds().isValid()) {
        map.fitBounds(featureGroup.getBounds());
      }
    }
    
    // Extract coordinates from a KML polygon
    function extractCoordinates(polygon) {
      const coordinates = [];
      const coordElements = polygon.getElementsByTagName('coordinates');
      if (coordElements.length > 0) {
        const coordText = coordElements[0].textContent.trim();
        const coordPairs = coordText.split(' ');
        
        for (let i = 0; i < coordPairs.length; i++) {
          const pair = coordPairs[i].trim();
          if (pair) {
            const parts = pair.split(',');
            if (parts.length >= 2) {
              const lng = parseFloat(parts[0]);
              const lat = parseFloat(parts[1]);
              coordinates.push([lat, lng]); // Note Leaflet uses [lat, lng] order
            }
          }
        }
      }
      return coordinates;
    }
    
    // Parse GeoJSON
    function parseGeoJSON(geojsonText, featureGroup, color) {
      try {
        const geojsonData = JSON.parse(geojsonText);
        
        // Log the first feature to debug property names
        if (geojsonData.features && geojsonData.features.length > 0) {
          console.log("Sample GeoJSON properties:", geojsonData.features[0].properties);
        }
        
        const layer = L.geoJSON(geojsonData, {
          style: function(feature) {
            return {
              color: color,
              weight: 2,
              opacity: 0.7,
              fillOpacity: 0.2
            };
          },
          onEachFeature: function(feature, layer) {
            // Extract the name from properties and bind tooltip
            let name = '';
            if (feature.properties) {
              if (feature.properties.name) {
                name = feature.properties.name;
              } else if (feature.properties.Name) {
                name = feature.properties.Name;
              } else if (feature.properties.NAME) {
                name = feature.properties.NAME;
              } else if (feature.properties.CONSTITUENCY) {
                name = feature.properties.CONSTITUENCY;
              } else if (feature.properties.constituency) {
                name = feature.properties.constituency;
              } else {
                // Try to find any property that might be a name
                for (const key in feature.properties) {
                  if (key.toLowerCase().includes('name') || 
                      key.toLowerCase().includes('title') ||
                      key.toLowerCase().includes('id') ||
                      key.toLowerCase().includes('constituency')) {
                    name = feature.properties[key];
                    break;
                  }
                }
              }
            }
            
            if (name) {
              layer.bindTooltip(name, {
                permanent: false,
                direction: 'center',
                className: 'electoral-tooltip'
              });
            }
            
            // Add mouseover/mouseout events for highlighting
            layer.on({
              mouseover: function(e) {
                const layer = e.target;
                layer.setStyle({
                  weight: 4,
                  color: '#FFA500',  // Orange highlight
                  fillOpacity: 0.4
                });
                if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                  layer.bringToFront();
                }
              },
              mouseout: function(e) {
                layer.setStyle({
                  weight: 2,
                  color: color,
                  fillOpacity: 0.2
                });
              }
            });
          }
        }).addTo(featureGroup);
        
        document.getElementById('status').textContent = `Loaded GeoJSON with ${geojsonData.features ? geojsonData.features.length : 0} features`;
        
        // Fit the map to the boundaries
        if (featureGroup.getBounds().isValid()) {
          map.fitBounds(featureGroup.getBounds());
        }
      } catch (error) {
        console.error("Error parsing GeoJSON:", error);
        document.getElementById('status').textContent = `Error parsing GeoJSON: ${error.message}`;
      }
    }
    
    // Add a polygon to the map
    function addPolygonToMap(coords, name, featureGroup, color) {
      const polygon = L.polygon(coords, {
        color: color,
        weight: 2,
        opacity: 0.7,
        fillOpacity: 0.2
      });
      
      if (name) {
        polygon.bindTooltip(name, {
          permanent: false,
          direction: 'center'
        });
      }
      
      // Add mouseover/mouseout events for highlighting
      polygon.on({
        mouseover: function(e) {
          const layer = e.target;
          layer.setStyle({
            weight: 4,
            color: '#FFA500',  // Orange highlight
            fillOpacity: 0.4
          });
          if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
            layer.bringToFront();
          }
        },
        mouseout: function(e) {
          polygon.setStyle({
            weight: 2,
            color: color,
            fillOpacity: 0.2
          });
        }
      });
      
      featureGroup.addLayer(polygon);
    }
    
    // Load data from GitHub
    async function loadAllLayers() {
      try {
        // GitHub raw URLs for the files
        const electoralUrl = 'https://raw.githubusercontent.com/tonghuikang/draw-sgp-electoral-boundaries/master/raw_data/ge2025_electoral_boundary.geojson';
        const pollingUrl = 'https://raw.githubusercontent.com/tonghuikang/draw-sgp-electoral-boundaries/master/raw_data/ge2025_polling_districts.kml';
        
        // Load Electoral Boundaries (GeoJSON)
        const electoralGeoJSON = await fetchData(electoralUrl);
        if (electoralGeoJSON) {
          parseGeoJSON(electoralGeoJSON, electoralLayer, '#0066FF');
        }
        
        // Load Polling Districts (KML)
        const pollingKML = await fetchData(pollingUrl);
        if (pollingKML) {
          parseKML(pollingKML, pollingLayer, '#FF0000');
        }
        
        // Update status
        document.getElementById('status').textContent = "Map loaded successfully";
        
        // Hide status message after a few seconds
        setTimeout(() => {
          document.getElementById('status').style.display = 'none';
        }, 3000);
        
      } catch (error) {
        console.error("Error loading layers:", error);
        document.getElementById('status').textContent = `Error loading map: ${error.message}`;
      }
    }
    
    // Add toggle controls
    document.getElementById('electoral-toggle').addEventListener('change', function() {
      if (this.checked) {
        map.addLayer(electoralLayer);
      } else {
        map.removeLayer(electoralLayer);
      }
    });
    
    document.getElementById('polling-toggle').addEventListener('change', function() {
      if (this.checked) {
        map.addLayer(pollingLayer);
      } else {
        map.removeLayer(pollingLayer);
      }
    });
    
    // Load all layers when the page loads
    window.addEventListener('load', loadAllLayers);
  </script>
</body>
</html>