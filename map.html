<!DOCTYPE html>
<html>
<head>
  <title>Singapore Electoral Boundaries 2025</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    body, html {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .status {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    .legend-item {
      margin-bottom: 5px;
    }
    .legend-color {
      display: inline-block;
      width: 20px;
      height: 10px;
      margin-right: 5px;
    }
    .leaflet-tooltip {
      font-weight: bold;
    }
    .polling-district-label div {
      text-align: center;
      white-space: nowrap;
      pointer-events: none;
    }
    /* Hide district labels by default */
    .district-label {
      display: none;
    }
    /* Show labels at zoom level 13+ */
    .show-labels .district-label {
      display: block;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <div class="controls">
    <div>
      <input type="checkbox" id="electoral-toggle" checked>
      <label for="electoral-toggle">Show Electoral Boundaries</label>
    </div>
    <div>
      <input type="checkbox" id="polling-toggle" checked>
      <label for="polling-toggle">Show Polling Districts</label>
    </div>
  </div>
  
  <div id="status" class="status">
    Loading map data...
  </div>
  
  <div class="legend">
    <div class="legend-item">
      <span class="legend-color" style="background-color: #0066FF;"></span>
      <span>Electoral Boundaries</span>
    </div>
    <div class="legend-item">
      <span class="legend-color" style="background-color: #FF0000;"></span>
      <span>Polling Districts</span>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Initialize the map
    const map = L.map('map').setView([1.3521, 103.8198], 12);
    
    // Add OpenStreetMap tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    
    // Create our layers
    let electoralLayer = L.featureGroup().addTo(map);
    let pollingLayer = L.featureGroup().addTo(map);
    
    // Function to fetch data from a URL
    async function fetchData(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
        }
        return await response.text();
      } catch (error) {
        console.error("Error fetching data:", error);
        document.getElementById('status').textContent = `Error loading data: ${error.message}`;
        return null;
      }
    }
    
    // Parse KML text
    function parseKML(kmlText, featureGroup, color) {
      // Create a temporary DOM to parse the KML
      const parser = new DOMParser();
      const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
      
      // Find all placemarks
      const placemarks = kmlDoc.getElementsByTagName('Placemark');
      document.getElementById('status').textContent = `Found ${placemarks.length} placemarks in KML`;
      
      for (let i = 0; i < placemarks.length; i++) {
        const placemark = placemarks[i];
        
        // Get name if available
        let name = '';
        const nameEl = placemark.getElementsByTagName('name')[0];
        if (nameEl) {
          name = nameEl.textContent;
        }
        
        // Find all polygons
        const polygons = placemark.getElementsByTagName('Polygon');
        for (let j = 0; j < polygons.length; j++) {
          const polygon = polygons[j];
          const coords = extractCoordinates(polygon);
          if (coords.length > 0) {
            addPolygonToMap(coords, name, featureGroup, color);
          }
        }
        
        // Find multigeometries
        const multiGeometries = placemark.getElementsByTagName('MultiGeometry');
        for (let j = 0; j < multiGeometries.length; j++) {
          const multiPolygons = multiGeometries[j].getElementsByTagName('Polygon');
          for (let k = 0; k < multiPolygons.length; k++) {
            const polygon = multiPolygons[k];
            const coords = extractCoordinates(polygon);
            if (coords.length > 0) {
              addPolygonToMap(coords, name, featureGroup, color);
            }
          }
        }
      }
      
      // Fit the map to the boundaries
      if (featureGroup.getBounds().isValid()) {
        map.fitBounds(featureGroup.getBounds());
      }
    }
    
    // Extract coordinates from a KML polygon
    function extractCoordinates(polygon) {
      const coordinates = [];
      const coordElements = polygon.getElementsByTagName('coordinates');
      if (coordElements.length > 0) {
        const coordText = coordElements[0].textContent.trim();
        const coordPairs = coordText.split(' ');
        
        for (let i = 0; i < coordPairs.length; i++) {
          const pair = coordPairs[i].trim();
          if (pair) {
            const parts = pair.split(',');
            if (parts.length >= 2) {
              const lng = parseFloat(parts[0]);
              const lat = parseFloat(parts[1]);
              coordinates.push([lat, lng]); // Note Leaflet uses [lat, lng] order
            }
          }
        }
      }
      return coordinates;
    }
    
    // Parse GeoJSON
    function parseGeoJSON(geojsonText, featureGroup, color, isPollingDistrict = false) {
      try {
        const geojsonData = JSON.parse(geojsonText);
        
        // Log the first feature to debug property names
        if (geojsonData.features && geojsonData.features.length > 0) {
          console.log("Sample GeoJSON properties:", geojsonData.features[0].properties);
        }
        
        const layer = L.geoJSON(geojsonData, {
          style: function(feature) {
            return {
              color: color,
              weight: 2,
              opacity: 0.7,
              fillOpacity: 0.2
            };
          },
          onEachFeature: function(feature, layer) {
            // Extract name and prepare tooltip text
            let tooltipText = '';
            
            if (feature.properties) {
              // For polling districts with elector size
              if (isPollingDistrict && feature.properties.name && feature.properties.elector_size) {
                tooltipText = `${feature.properties.name}: ${feature.properties.elector_size.toLocaleString()} electors`;
                
                // Add district code label that will only show at certain zoom levels
                if (feature.properties.name) {
                  // Create a fixed label at the center of the district
                  const label = L.marker(layer.getBounds().getCenter(), {
                    icon: L.divIcon({
                      className: 'polling-district-label',
                      html: `<div class="district-label" style="background: white; 
                                      opacity: 0.8; 
                                      padding: 1px 3px; 
                                      font-size: 8px; 
                                      color: black;
                                      border-radius: 2px;
                                      box-shadow: 0 0 1px #000;">${feature.properties.name}</div>`,
                      iconSize: [30, 12],
                      iconAnchor: [15, 6] 
                    }),
                    interactive: false
                  }).addTo(map);
                }
              } 
              // For electoral boundaries
              else {
                if (feature.properties.name) {
                  tooltipText = feature.properties.name;
                } else if (feature.properties.Name) {
                  tooltipText = feature.properties.Name;
                } else if (feature.properties.NAME) {
                  tooltipText = feature.properties.NAME;
                } else if (feature.properties.CONSTITUENCY) {
                  tooltipText = feature.properties.CONSTITUENCY;
                } else if (feature.properties.constituency) {
                  tooltipText = feature.properties.constituency;
                } else {
                  // Try to find any property that might be a name
                  for (const key in feature.properties) {
                    if (key.toLowerCase().includes('name') || 
                        key.toLowerCase().includes('title') ||
                        key.toLowerCase().includes('id') ||
                        key.toLowerCase().includes('constituency')) {
                      tooltipText = feature.properties[key];
                      break;
                    }
                  }
                }
              }
            }
            
            if (tooltipText) {
              layer.bindTooltip(tooltipText, {
                permanent: false,
                direction: 'center',
                className: 'electoral-tooltip'
              });
            }
            
            // Add mouseover/mouseout events for highlighting
            layer.on({
              mouseover: function(e) {
                const layer = e.target;
                layer.setStyle({
                  weight: 4,
                  color: '#FFA500',  // Orange highlight
                  fillOpacity: 0.4
                });
                if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                  layer.bringToFront();
                }
              },
              mouseout: function(e) {
                // Reset style
                layer.setStyle({
                  weight: 2,
                  color: color,
                  fillOpacity: 0.2
                });
              }
            });
          }
        }).addTo(featureGroup);
        
        document.getElementById('status').textContent = `Loaded GeoJSON with ${geojsonData.features ? geojsonData.features.length : 0} features`;
        
        // Fit the map to the boundaries
        if (featureGroup.getBounds().isValid()) {
          map.fitBounds(featureGroup.getBounds());
        }
      } catch (error) {
        console.error("Error parsing GeoJSON:", error);
        document.getElementById('status').textContent = `Error parsing GeoJSON: ${error.message}`;
      }
    }
    
    // Add a polygon to the map
    function addPolygonToMap(coords, name, featureGroup, color) {
      const polygon = L.polygon(coords, {
        color: color,
        weight: 2,
        opacity: 0.7,
        fillOpacity: 0.2
      });
      
      if (name) {
        polygon.bindTooltip(name, {
          permanent: false,
          direction: 'center'
        });
      }
      
      // Add mouseover/mouseout events for highlighting
      polygon.on({
        mouseover: function(e) {
          const layer = e.target;
          layer.setStyle({
            weight: 4,
            color: '#FFA500',  // Orange highlight
            fillOpacity: 0.4
          });
          if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
            layer.bringToFront();
          }
        },
        mouseout: function(e) {
          polygon.setStyle({
            weight: 2,
            color: color,
            fillOpacity: 0.2
          });
        }
      });
      
      featureGroup.addLayer(polygon);
    }
    
    // Load data from GitHub
    async function loadAllLayers() {
      try {
        // GitHub URLs for the files
        const electoralUrl = 'https://raw.githubusercontent.com/tonghuikang/draw-sgp-electoral-boundaries/master/raw_data/ge2025_electoral_boundary.geojson';
        const pollingDistrictsUrl = 'https://raw.githubusercontent.com/tonghuikang/draw-sgp-electoral-boundaries/master/processed_data/ge2025_polling_districts_with_elector_size.geojson';
        
        // Load Electoral Boundaries (GeoJSON)
        const electoralGeoJSON = await fetchData(electoralUrl);
        if (electoralGeoJSON) {
          parseGeoJSON(electoralGeoJSON, electoralLayer, '#0066FF', false);
        }
        
        // Load Polling Districts with Elector Size (GeoJSON)
        const pollingGeoJSON = await fetchData(pollingDistrictsUrl);
        if (pollingGeoJSON) {
          parseGeoJSON(pollingGeoJSON, pollingLayer, '#FF0000', true);
        }
        
        // Update status
        document.getElementById('status').textContent = "Map loaded successfully";
        
        // Hide status message after a few seconds
        setTimeout(() => {
          document.getElementById('status').style.display = 'none';
        }, 3000);
        
      } catch (error) {
        console.error("Error loading layers:", error);
        document.getElementById('status').textContent = `Error loading map: ${error.message}`;
      }
    }
    
    // Add toggle controls
    document.getElementById('electoral-toggle').addEventListener('change', function() {
      if (this.checked) {
        map.addLayer(electoralLayer);
      } else {
        map.removeLayer(electoralLayer);
      }
    });
    
    document.getElementById('polling-toggle').addEventListener('change', function() {
      if (this.checked) {
        map.addLayer(pollingLayer);
      } else {
        map.removeLayer(pollingLayer);
      }
    });
    
    
    // Handle showing/hiding labels based on zoom level
    map.on('zoomend', function() {
      const zoom = map.getZoom();
      const mapElement = document.getElementById('map');
      
      // Show labels only at zoom level 14+
      if (zoom >= 14) {
        mapElement.classList.add('show-labels');
      } else {
        mapElement.classList.remove('show-labels');
      }
    });
    
    // Load all layers when the page loads
    window.addEventListener('load', function() {
      loadAllLayers();
      
      // Set initial label visibility based on starting zoom
      const zoom = map.getZoom();
      const mapElement = document.getElementById('map');
      if (zoom >= 14) {
        mapElement.classList.add('show-labels');
      }
    });
  </script>
</body>
</html>